#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use strum_macros::FromRepr;

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, FromRepr)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum Instruction {
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    Pow,
    Gt,
    Ge,
    Lt,
    Le,
    Eq,
    Ne,
    Pop,
    LdLocal,
    LdLocalW,
    LdGlobal,
    LdGlobalW,
    Constant,
    ConstantW,
    Pos,
    Neg,
    TypeOf,
    BitNot,
    Not,
    StoreLocal,
    StoreLocalW,
    StoreGlobal,
    StoreGlobalW,
    Ret,
    Call,
    JmpFalseP,
    Jmp,
    StaticPropAccess,
    StaticPropAccessW,
    DynamicPropAccess,
    ArrayLit,
    ArrayLitW,
    ObjLit,
    ObjLitW,
    This,
    StaticPropSet,
    StaticPropSetW,
    DynamicPropSet,
    LdLocalExt,
    LdLocalExtW,
    StoreLocalExt,
    StoreLocalExtW,
    StrictEq,
    StrictNe,
    Try,
    TryEnd,
    Throw,
    Yield,
    JmpFalseNP,
    JmpTrueP,
    JmpTrueNP,
    JmpNullishP,
    JmpNullishNP,
    BitOr,
    BitXor,
    BitAnd,
    BitShl,
    BitShr,
    BitUshr,
    ObjIn,
    InstanceOf,
    ImportDyn,
    ImportStatic,
    ExportDefault,
    ExportNamed,
    Debugger,
    Global,
    Super,
    RevStck,
    Undef,
    Break,
    Await,
    Nan,
    Infinity,
    IntrinsicOp,
    CallSymbolIterator,
    CallForInIterator,
    DeletePropertyStatic,
    DeletePropertyDynamic,
    Switch,
}

// Some instruction opcodes have a separate u8 constant to be used in for example match guards,
// where `Instruction::Pop as u8` isn't allowed
pub const POP: u8 = Instruction::Pop as u8;
pub const RET: u8 = Instruction::Ret as u8;
