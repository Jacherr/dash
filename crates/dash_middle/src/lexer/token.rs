use std::borrow::Cow;
use std::fmt;

use derive_more::Display;
use either::Either;

/// The type of a token
///
/// These are generated by the lexer, and used by the Parser to
/// produce an abstract syntax tree.
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Display)]
pub enum TokenType {
    #[display(fmt = "(")]
    LeftParen,

    #[display(fmt = ")")]
    RightParen,

    #[display(fmt = "{{")]
    LeftBrace,

    #[display(fmt = "}}")]
    RightBrace,

    #[display(fmt = "$")]
    Dollar,

    #[display(fmt = "[")]
    LeftSquareBrace,

    #[display(fmt = "]")]
    RightSquareBrace,

    #[display(fmt = "[]")]
    EmptySquareBrace,

    #[display(fmt = ",")]
    Comma,

    #[display(fmt = ".")]
    Dot,

    #[display(fmt = "-")]
    Minus,

    #[display(fmt = "--")]
    Decrement,

    #[display(fmt = "+")]
    Plus,

    #[display(fmt = ":")]
    Colon,

    #[display(fmt = "++")]
    Increment,

    #[display(fmt = "++")]
    PrefixIncrement,

    #[display(fmt = "--")]
    PrefixDecrement,

    #[display(fmt = "++")]
    PostfixIncrement,

    #[display(fmt = "--")]
    PostfixDecrement,

    #[display(fmt = "*")]
    Star,

    #[display(fmt = "/")]
    Slash,

    #[display(fmt = ";")]
    Semicolon,

    #[display(fmt = "=")]
    Assignment,

    #[display(fmt = "+=")]
    AdditionAssignment,

    #[display(fmt = "-=")]
    SubtractionAssignment,

    #[display(fmt = "*=")]
    MultiplicationAssignment,

    #[display(fmt = "/=")]
    DivisionAssignment,

    #[display(fmt = "%=")]
    RemainderAssignment,

    #[display(fmt = "%")]
    Remainder,

    #[display(fmt = "**=")]
    ExponentiationAssignment,

    #[display(fmt = "**")]
    Exponentiation,

    #[display(fmt = "<<")]
    LeftShift,

    #[display(fmt = "<<=")]
    LeftShiftAssignment,

    #[display(fmt = ">>=")]
    RightShiftAssignment,

    #[display(fmt = ">>")]
    RightShift,

    #[display(fmt = ">>=")]
    UnsignedRightShiftAssignment,

    #[display(fmt = ">>>")]
    UnsignedRightShift,

    #[display(fmt = "&=")]
    BitwiseAndAssignment,

    #[display(fmt = "&")]
    BitwiseAnd,

    #[display(fmt = "|=")]
    BitwiseOrAssignment,

    #[display(fmt = "|")]
    BitwiseOr,

    #[display(fmt = "^=")]
    BitwiseXorAssignment,

    #[display(fmt = "^")]
    BitwiseXor,

    #[display(fmt = "~")]
    BitwiseNot,

    #[display(fmt = "&&=")]
    LogicalAndAssignment,

    #[display(fmt = "&&")]
    LogicalAnd,

    #[display(fmt = "||=")]
    LogicalOrAssignment,

    #[display(fmt = "||")]
    LogicalOr,

    #[display(fmt = "??=")]
    LogicalNullishAssignment,

    #[display(fmt = "??")]
    NullishCoalescing,

    #[display(fmt = "!")]
    LogicalNot,

    #[display(fmt = "==")]
    Equality,

    #[display(fmt = "===")]
    StrictEquality,

    #[display(fmt = "!=")]
    Inequality,

    #[display(fmt = "!==")]
    StrictInequality,

    #[display(fmt = ">")]
    Greater,

    #[display(fmt = ">=")]
    GreaterEqual,

    #[display(fmt = "<")]
    Less,

    #[display(fmt = "<=")]
    LessEqual,

    /// Identifier: foo
    Identifier,

    /// String: "foo"
    String,

    /// Template literal: `foo`
    TemplateLiteral,

    /// Number: 42
    NumberDec,

    /// Regex literal: /a+b/g
    RegexLiteral,

    #[display(fmt = "0x")]
    NumberHex,

    #[display(fmt = "0b")]
    NumberBin,

    #[display(fmt = "0o")]
    NumberOct,

    #[display(fmt = "if")]
    If,

    #[display(fmt = "else")]
    Else,

    #[display(fmt = "function")]
    Function,

    #[display(fmt = "class")]
    Class,

    #[display(fmt = "extends")]
    Extends,

    #[display(fmt = "static")]
    Static,

    #[display(fmt = "var")]
    Var,

    #[display(fmt = "let")]
    Let,

    #[display(fmt = "const")]
    Const,

    #[display(fmt = "return")]
    Return,

    #[display(fmt = "throw")]
    Throw,

    #[display(fmt = "try")]
    Try,

    #[display(fmt = "catch")]
    Catch,

    #[display(fmt = "finally")]
    Finally,

    #[display(fmt = "false")]
    FalseLit,

    #[display(fmt = "true")]
    TrueLit,

    #[display(fmt = "null")]
    NullLit,

    #[display(fmt = "undefined")]
    UndefinedLit,

    #[display(fmt = "yield")]
    Yield,

    #[display(fmt = "new")]
    New,

    /// Condition: foo ? bar : baz
    Conditional,

    #[display(fmt = "?.")]
    OptionalChaining,

    #[display(fmt = "for")]
    For,

    #[display(fmt = "while")]
    While,

    #[display(fmt = "in")]
    In,

    #[display(fmt = "instanceof")]
    Instanceof,

    #[display(fmt = "await ")]
    Await,

    #[display(fmt = "delete ")]
    Delete,

    #[display(fmt = "void ")]
    Void,

    #[display(fmt = "typeof ")]
    Typeof,

    #[display(fmt = "break")]
    Break,

    #[display(fmt = "continue")]
    Continue,

    #[display(fmt = "import")]
    Import,

    #[display(fmt = "export")]
    Export,

    #[display(fmt = "default")]
    Default,

    #[display(fmt = "debugger")]
    Debugger,

    #[display(fmt = "of")]
    Of,

    #[display(fmt = "=>")]
    FatArrow,

    #[display(fmt = "#")]
    Hash,

    #[display(fmt = "switch")]
    Switch,

    #[display(fmt = "case")]
    Case,

    #[display(fmt = "get")]
    Get,

    #[display(fmt = "set")]
    Set,

    #[display(fmt = "async")]
    Async,

    #[display(fmt = "EOF")]
    Eof,
}

/// Tokens that are used to assign
pub const ASSIGNMENT_TYPES: &[TokenType] = &[
    TokenType::Assignment,
    TokenType::AdditionAssignment,
    TokenType::SubtractionAssignment,
    TokenType::MultiplicationAssignment,
    TokenType::DivisionAssignment,
    TokenType::RemainderAssignment,
    TokenType::ExponentiationAssignment,
    TokenType::LeftShiftAssignment,
    TokenType::RightShiftAssignment,
    TokenType::UnsignedRightShiftAssignment,
    TokenType::BitwiseAndAssignment,
    TokenType::BitwiseOrAssignment,
    TokenType::BitwiseXorAssignment,
    TokenType::LogicalAndAssignment,
    TokenType::LogicalOrAssignment,
    TokenType::LogicalNullishAssignment,
];

pub const VARIABLE_TYPES: &[TokenType] = &[TokenType::Var, TokenType::Let, TokenType::Const];
pub const IDENTIFIER_TYPES: &[TokenType] = &[TokenType::Identifier, TokenType::Dollar];

impl TokenType {
    /// Checks if this token is a variable kind
    pub fn is_variable(&self) -> bool {
        VARIABLE_TYPES.contains(self)
    }

    /// Checks if this token is a possible symbol for identfiers
    pub fn is_identifier(&self) -> bool {
        // even though `$` is its own token, it is also a valid identifier
        IDENTIFIER_TYPES.contains(self)
    }
}

impl From<&str> for TokenType {
    fn from(s: &str) -> Self {
        match s {
            "if" => Self::If,
            "else" => Self::Else,
            "function" => Self::Function,
            "var" => Self::Var,
            "let" => Self::Let,
            "const" => Self::Const,
            "return" => Self::Return,
            "throw" => Self::Throw,
            "try" => Self::Try,
            "catch" => Self::Catch,
            "finally" => Self::Finally,
            "true" => Self::TrueLit,
            "false" => Self::FalseLit,
            "null" => Self::NullLit,
            "undefined" => Self::UndefinedLit,
            "yield" => Self::Yield,
            "new" => Self::New,
            "for" => Self::For,
            "while" => Self::While,
            "in" => Self::In,
            "instanceof" => Self::Instanceof,
            "async" => Self::Async,
            "await" => Self::Await,
            "delete" => Self::Delete,
            "void" => Self::Void,
            "typeof" => Self::Typeof,
            "continue" => Self::Continue,
            "break" => Self::Break,
            "import" => Self::Import,
            "export" => Self::Export,
            "default" => Self::Default,
            "debugger" => Self::Debugger,
            "of" => Self::Of,
            "class" => Self::Class,
            "extends" => Self::Extends,
            "static" => Self::Static,
            "switch" => Self::Switch,
            "case" => Self::Case,
            "get" => Self::Get,
            "set" => Self::Set,
            _ => Self::Identifier,
        }
    }
}

impl From<TokenType> for &str {
    fn from(tt: TokenType) -> Self {
        match tt {
            TokenType::Plus => "+",
            TokenType::Minus => "-",
            _ => unimplemented!(),
        }
    }
}

/// A token
#[derive(Debug, Clone)]
pub struct Token<'a> {
    /// The type of token
    pub ty: TokenType,
    /// The full string representation of this token
    pub full: Cow<'a, str>,
    /// Location of this token in the input string
    pub loc: Location,
}

/// A location, represents where a token can be found in a source code string
#[derive(Debug, Clone, Copy)]
pub struct Location {
    /// Line number
    pub line: usize,
    /// Byte offset
    pub offset: usize,
    /// Byte offset for the line this token is on
    pub line_offset: usize,
}

pub struct FormattableError<'a, 'b> {
    pub loc: &'a Location,
    pub source: &'a [u8],
    pub tok: Either<&'b str, char>,
    pub message: &'a str,
    pub display_token: bool,
    pub help: Option<Box<dyn fmt::Display + 'a>>,
}

impl<'a, 'b> fmt::Display for FormattableError<'a, 'b> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let offset = if self.loc.line <= 1 {
            self.loc.line_offset
        } else {
            self.loc.line_offset + 1
        };

        let column = self.loc.offset - offset;

        write!(f, "error: {}\n", self.message)?;
        write!(f, "--> script.js:{}:{}\n\n", self.loc.line, column)?;

        let line = {
            let partial = &self.source[offset..];
            let end = partial.iter().position(|&c| c == b'\n').unwrap_or(partial.len());
            &partial[..end]
        };

        let token_len = match &self.tok {
            Either::Left(s) => s.len(),
            Either::Right(c) => c.len_utf8(),
        };

        let pointer_start = self.loc.offset - self.loc.line_offset;

        write!(f, "{}\n", String::from_utf8_lossy(line))?;
        write!(f, "{}", " ".repeat(pointer_start))?;
        write!(f, "{}", "^".repeat(token_len))?;

        if let Some(help) = &self.help {
            write!(f, "\n= help: {}", help)?;
        }

        Ok(())
    }
}
