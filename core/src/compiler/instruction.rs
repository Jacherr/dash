use crate::vm::instruction::{Instruction as VMInstruction, InstructionInner, Opcode};

/// A compiler instruction
///
/// Represents either an operation or a value, stored as an enum for the discriminant.
#[derive(Debug, Clone)]
pub enum Instruction {
    /// An operation code
    Op(Opcode),
    /// An operand carrying an index into a constant
    Operand(u8),
}

impl From<Instruction> for VMInstruction {
    fn from(i: Instruction) -> Self {
        match i {
            Instruction::Op(o) => VMInstruction::from(o),
            Instruction::Operand(op) => VMInstruction(InstructionInner { operand: op }),
        }
    }
}

/// Converts a set of compiler instructions to a set of VM instructions
///
/// It is safe to go from compiler instructions to VM instructions because instructions
/// generated by the compiler have a discriminant attached to them,
/// so we can check for its variant using a match statement.
/// However, it is not safe to go the other way.
pub fn to_vm_instructions(instructions: Vec<Instruction>) -> Vec<VMInstruction> {
    instructions.into_iter().map(From::from).collect()
}
